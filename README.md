# library-heist
csc120 final project
Sofia Zasiebida 
Liyana Asaria-Issa


DESIGN JUSTIFICATION:

Initially, we had discussed creating a map where each location had an x and y coordinate. The user could say they wanted to move 10 feet north for example, and then their coordinates would update, and check against the area occupied by each building to see if the user had reached one. While this would’ve been functional, we didn't like how it left the user in the dark and meant we had to develop physical boundaries and do a lot of comparison to make it functional with movement. Sofia came up with the idea of introducing rooms, a map in which there was no way for the user to be in between locations, and instead of having coordinates, the north, east, south and west values indicated the number(index in the map) of the room that was to the north, east, south and west, respectively, of the room. The rooms are stored in an array list that is the map. This means that the user only has to keep track of the room number that they are in and we can print out information regarding what is to the north, east, south and west of the user. It made it simpler to handle user input of directions as well and to move the user through the map. A grid map was also the simplest one we could thing of and made it easy to add new rooms as we developed the game to the array list map. 


REFLECTION:

First, we developed an idea for a game objective and created a rough outline of a  storyline. We began building this project by making our architecture diagram in class. After sorting our classes (room, item, user, and game), determining their functions, and figuring out how they would interact, we made the map and developed the characters, items, and users in the game. Our approach was to create the functionality for each class separately and bring them together at the end with a storyline and a game class. Given that we were working in a pair, we split up the work (writing our code and classes separately) and then came together to teach eachother how our code worked and determine how to bring our separate classes together. 

To experiment with how the game was outputting in the terminal, we learned how to customize text printouts and how to display a graphic! We utilized a game over image to indicate to the user that they lost the game. We also noticed, particularly during demo day, that players often had trouble referring back to important information as all of the text was uniform. We spent some time adjusting the aesthetics of the printout and that included finding a way to italicize important printouts by using string formatting methods.. In our case, we italicized the location of the user so that they could navigate independently whenever they want.

One thing that we wish we could’ve implemented differently is the script. Our script is created with a whole bunch of if statements and integers that indicate where in the timeline the player is. This makes it so that our code is bulky, sometimes hard to follow and we were quite prone to error. It took a lot of time to create the script and it felt pretty inefficient. 

If we had unlimited time to complete this game, we would love to implement more user freedom, the ability to pick up dropped items, and a time constraint. While the user has the ability to make choices and move wherever at any time, we feel like the game is a bit too structured. We are limited by the structure of our script, and the fact that the user is being brought through a storyline, rather than getting to create their own. We chose to implement the game this way since we felt it was the easiest to build off of. We do have a drop function, but our code does not keep track of the location of dropped items, making it impossible for users to pick up items they dropped. This feels like a straightforward fix, but there are a lot of moving parts to keep track of, and we did not have the time to iron out that feature. Adding it in would probably include making the item class more complex to include locations and additional prompts when the user runs into dropped items. Lastly, our original game idea kept track of time (so that you could complete the mission in the timeframe) by adding a specific number of minutes (ie. 10) every time the user moved or made a decision. This would add another way to die, makes it seem more real and encourages players to think critically about the decisions they make. Along with this, users will aim to win, and then play again to win quicker. 

The most helpful piece of feedback we received was from Ab, telling us to start slow and simple particularly with the item class. This project was particularly daunting, especially given how much we wanted to do, and how much felt new to us. Even just the thought of creating a map or a scanner that continually took in user input were particularly overwhelming. Additionally, trying to figure out how all the classes needed to interact felt challenging. When we brought these concerns to Ab in class they told us to start slow! This is something that Jordan had mentioned to us all semester as well. Taking it in bits and pieces made it easier, and made our collaboration more effective. It was easier to share what we had worked on and it was easier to split up work when we took the project in chunks. This advice was mostly a mindset change but had a great effect on how we moved through the project and felt about it as well. 

Some advice we would give ourselves would be to budget time for debugging and to remember that the map and characters in the game don’t need to be as tangible as they would be if we were making a visual game. We were really attached to the idea of creating a map that mirrored the physical world, but letting go of that as a necessity allowed us to create a simpler map (even though it may be a little more complicated to wrap our heads around). At first, we thought that the characters that the user interacts with had to be their own class. After realizing that their only function was to speak to the user via print statements, we simplified the interactions and removed this class. We would give ourselves the advice to pay attention to the architecture diagram and figure out how classes interact before we started coding unnecessary functionality. Another thing we would have told ourselves is that debugging is a large part of this project! As with most coding projects you have to try things that don’t work to get to things that do! 

We really loved the group work component of this project. We balanced each other well. One of us took the lead on creating the map, user class, item class, and room class and another one took on the script and communication between classes. We were also proud of ourselves for being able to tackle issues with the code as issues with the code and not an issue with each other. We were considerate of the other person and able to give constructive feedback that helped us move forward with the project. It worked out that we each got to demonstrate our strengths in this project and that is a large reason why it turned out as well as it did. 


